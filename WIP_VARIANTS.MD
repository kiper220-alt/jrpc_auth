# Дисклеймер.
Данный файл описыват все возможные варианты авторизации для gpui через веб интерфейс по json-rpc.

# Хранилище данных.
- `MemoryAuthStorage` &mdash; идеально в случае, когда относительно маленькое(до 1'000) количество одновременных авторизаций. Представляет из себя простое хранение токенов в QHash. Все токены исчезают после перезапуска приложения.
- `RedisAuthSorage` &mdash; идеально в случае, когда относительно большое количество одновременных авторизаций. При любом количестве токенов время обращения O(1). Все токены хранятся до первой не прошедшей проверки life-time (и версии в случае JWT).
- `ValkeyAuthStorage` &mdash; аналогичен RedisAuthStorage.

# Токены.
|  | <center>➕</center> | <center>➖</center> |
|----------|---|---|
| Обычное число | маленький размер. Быстрая .<br/>генерация Простое хранение. | Сложная реализация удаления по<br/> истечению life-time или изменении пароля. |
| `JWT` токен | Life-Time, пароль по дате изменения | Большой размер. Медленная генерация.<br/> Не полная реализация `JWT` из OAuth 2.0 |
| Kerberos TGS | Временем жизни токена управляет KRB5 | Машина с gpui должна быть введена в <br/> домен и иметь доступ в KDC.<br/> Требует gssapi авторизацию с Front-End<br/> Сложно в реализации. |

В случае использования токенов `JWT`, часть информации можно хранить в самом токене, в том числе информацию о пользователе.

## Kerberos
Kerberos: https://docs.altlinux.org/ru-RU/domain/10.4/html/samba/ch06s10s02.html

Kerberos метод не подходит по ряду причин:
1. Переусложнение API добавлением стадии с gssapi запросом TGS ключей(исходная задача, приближённое соответствие https://github.com/dev-family/admiral/blob/master/src/authProvider.ts).
2. Необходимость работы с KDC, которого может не быть на текущей машины, следовательно расширение API (пункт 1.)
3. 

### Обычные и `JWT`
Остаются варианты с "обычным числом" и `JWT`-токеном. Второй, в данном контексте, является усложнённой версией первого, в следствии того, что содержит в себе следущую информацию:
- `iss` &mdash; принципал, который запросил `JWT`(`id` пользователя). 
- `sub` &mdash; принципал, который является субъектом `JWT` (сам `gpui`).
- `aud` &mdash; реципиенты `JWT`.
- `exp` &mdash; дата истечения `JWT`.
- `nbf` &mdash; начальная дата работы `JWT`.
- `iat` &mdash; дата создания `JWT`.
- `jti` &mdash; уникальный идентификатор `JWT`.

Для пометки ключа в чёрный список можно получать дату изменения записи пользователя, до которой все JWT токены можно считать истекшими. `JWT` ключ просто как способ хранение и подписи информации. Хранить его можно как в `MemoryAuthStorage`, так и в `RedisAuthStorage`, т.к. в случае первого нет реализации возможности удаления по истечению времени жизни, т.к. можно проверить сам ключ. Единственное, что необходимо хранить в самом `AuthStorage` &mdash; `jti`. 
Проверка `JWT` сводится к:
1. Проверка подписи закрытым ключом.
2. Проверка даты истечения. Если истекла, удалить `jti` из `AuthStorage` при наличии.
4. Проверка `jti` на наличие в `AuthStorage`. Проверить соответствия пользователя по `jti` и `iss` в `JWT`.
5. Сверка даты создания с датой последнего изменения пользователья в `UserStorage`(можно раз в 5 минут, для сокращение вызовов к Samba например.). Если проверка не прошла, удалить `jti` из `AuthStorage`.

Также не маловажный плюс, для того, чтобы проверить `JWT` ключ в остальных сервисах, необходимо и достаточно выполнить все пункты из примера выше.

В случае "обычного ключа" пользователь передаёт некоторый `id`, по которому будет получаться информация о ключе в `AuthStorage`.
Разница данных подходов в том, что засчёт подписи `JWT`, мы делигируем хранение части информации самому пользователю, оставаясь увереным, что нас не обманут. В случае с "обычным ключом", дополнительно необходимо хранить время, реципиенты, уникальным идентификатор и субъект, что необходимо для оставления возможности к расширению, и может усложнить хранение информации.

Для использования JWT в C++ можно использовать библиотеку `cpp-jwt-1.5-alt1`.
